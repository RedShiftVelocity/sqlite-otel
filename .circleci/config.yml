version: 2.1

commands:
  setup_go_modules:
    steps:
      - restore_cache:
          keys:
            - go-mod-v1-{{ checksum "go.sum" }}
            - go-mod-v1-
      - run:
          name: Download dependencies
          command: go mod download
      - save_cache:
          key: go-mod-v1-{{ checksum "go.sum" }}
          paths:
            - ~/go/pkg/mod

executors:
  go-executor:
    docker:
      - image: cimg/go:1.21.6
    working_directory: ~/repo
  
  docker-executor:
    docker:
      - image: cimg/go:1.21.6
    working_directory: ~/repo

jobs:
  # First: Build the application
  build:
    executor: go-executor
    steps:
      - checkout
      - setup_go_modules
      - run:
          name: Build current platform binary
          command: |
            set -e
            echo "Building sqlite-otel binary..."
            make build
            # Verify binary was created
            if [ ! -f "sqlite-otel" ]; then
              echo "Error: Binary sqlite-otel not found after build"
              exit 1
            fi
            echo "Binary built successfully: $(ls -la sqlite-otel)"
      - run:
          name: Build for all platforms
          command: |
            set -e
            echo "Building for all platforms..."
            make build-all
            echo "Cross-platform build complete:"
            ls -la dist/
      - run:
          name: Test binary execution
          command: |
            set -e
            echo "Testing binary execution..."
            ./sqlite-otel --version
            echo "Binary executes successfully"
      - run:
          name: Collect binaries
          command: |
            set -e
            mkdir -p binaries
            cp sqlite-otel binaries/
            cp dist/* binaries/ 2>/dev/null || true
            echo "Collected binaries:"
            ls -la binaries/
      - store_artifacts:
          path: binaries/
          destination: binaries
      - persist_to_workspace:
          root: .
          paths:
            - sqlite-otel
            - binaries/
            - dist/

  # Second: Run tests (after successful build)
  test:
    executor: go-executor
    steps:
      - checkout
      - attach_workspace:
          at: .
      - setup_go_modules
      - run:
          name: Run go vet
          command: |
            echo "Running go vet..."
            go vet ./...
      - run:
          name: Install test reporter
          command: go install github.com/jstemmer/go-junit-report/v2@latest
      - run:
          name: Run tests with race detection
          command: |
            set -e
            echo "Running tests with race detection..."
            mkdir -p /tmp/test-results
            # Run tests and capture both stdout and exit code
            go test -race -coverprofile=coverage.out -v ./... 2>&1 | tee /tmp/test-results/go-test.out
            # Capture the exit code from go test (not tee)
            test_exit_code=${PIPESTATUS[0]}
            # Convert to JUnit XML format for CircleCI
            cat /tmp/test-results/go-test.out | go-junit-report -set-exit-code > /tmp/test-results/junit.xml
            # Exit with the original test exit code
            exit $test_exit_code
      - run:
          name: Generate coverage report
          command: |
            set -e
            echo "Generating coverage report..."
            go tool cover -html=coverage.out -o coverage.html
            echo "Coverage report generated"
            # Display coverage summary
            go tool cover -func=coverage.out | tail -1
      - run:
          name: Test binary functionality
          command: |
            set -e
            echo "Testing binary functionality..."
            # Start the binary in background
            timeout 5 ./sqlite-otel --port 0 --db-path ./test.db || true
            echo "Binary functionality test completed"
      - store_test_results:
          path: /tmp/test-results
      - store_artifacts:
          path: coverage.html
          destination: coverage
      - store_artifacts:
          path: coverage.out
          destination: coverage.out

  # Third: Build and validate Docker container
  docker-build-and-test:
    machine:
      image: ubuntu-2204:2024.01.1
    resource_class: large
    working_directory: ~/repo
    steps:
      - checkout
      - attach_workspace:
          at: .
      - run:
          name: Setup Docker environment
          command: |
            set -e
            echo "Setting up Docker environment..."
            
            # Check Docker daemon status
            docker version
            docker info
            
            # Check required files exist
            if [ ! -f "Dockerfile" ]; then
              echo "ERROR: Dockerfile not found"
              exit 1
            fi
            echo "✓ Dockerfile found"
            
            if [ ! -f "go.mod" ]; then
              echo "ERROR: go.mod not found"
              exit 1
            fi
            echo "✓ go.mod found"
            
            if [ ! -f "Makefile" ]; then
              echo "ERROR: Makefile not found"
              exit 1
            fi
            echo "✓ Makefile found"
            
            # Clean up any existing containers/images
            docker container prune -f || true
            docker image prune -f || true
            
            echo "Docker environment ready"
      - run:
          name: Build Docker image
          command: |
            set -e
            echo "Building Docker image..."
            
            # Build with progress output and better error handling
            if ! docker build -t sqlite-otel-collector:test . --progress=plain; then
              echo "ERROR: Docker build failed"
              echo "Checking available disk space:"
              df -h
              echo "Checking Docker daemon logs:"
              sudo journalctl -u docker.service --no-pager -n 50 || true
              exit 1
            fi
            
            echo "✅ Docker image built successfully"
            
            # Show image details
            echo "Image details:"
            docker images sqlite-otel-collector:test
            
            # Get image size
            image_size=$(docker images sqlite-otel-collector:test --format "{{.Size}}")
            echo "Final image size: $image_size"
            
            # Verify image can be inspected
            docker inspect sqlite-otel-collector:test > /dev/null
            echo "✅ Image inspection successful"
      - run:
          name: Test Docker container startup
          command: |
            set -e
            echo "Testing Docker container startup..."
            
            # Clean up any existing containers
            docker rm -f sqlite-otel-test 2>/dev/null || true
            
            # Use a fixed high port to avoid randomness issues
            test_port=25318
            echo "Using test port: $test_port"
            
            # Check if port is available
            if netstat -tuln | grep -q ":$test_port "; then
              echo "Port $test_port is in use, trying alternative"
              test_port=25319
            fi
            
            # Start container with better error handling
            echo "Starting container on port $test_port..."
            if ! container_id=$(docker run -d --name sqlite-otel-test -p $test_port:4318 sqlite-otel-collector:test); then
              echo "ERROR: Failed to start container"
              echo "Checking available ports:"
              netstat -tuln | grep LISTEN || true
              exit 1
            fi
            
            echo "Container started with ID: $container_id"
            
            # Wait for container to be ready with timeout and health checks
            echo "Waiting for container to be ready..."
            max_attempts=30
            attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              if docker ps --filter name=sqlite-otel-test | grep -q sqlite-otel-test; then
                echo "✅ Container is running (attempt $attempt)"
                break
              else
                echo "Container not running yet (attempt $attempt/$max_attempts)"
                if [ $attempt -eq $max_attempts ]; then
                  echo "ERROR: Container failed to start after $max_attempts attempts"
                  echo "Container status:"
                  docker ps -a --filter name=sqlite-otel-test
                  echo "Container logs:"
                  docker logs sqlite-otel-test
                  echo "Docker system info:"
                  docker system df
                  exit 1
                fi
                sleep 2
                attempt=$((attempt + 1))
              fi
            done
            
            # Save the test port for subsequent steps
            echo "export TEST_PORT=$test_port" >> $BASH_ENV
            echo "✅ Container is running successfully on port $test_port"
      - run:
          name: Test Docker container health
          command: |
            set -e
            echo "Testing Docker container health endpoint..."
            
            # Source the test port
            source $BASH_ENV
            echo "Testing health endpoint on port $TEST_PORT"
            
            # Wait a bit more for the application to fully start
            sleep 5
            
            # Test health endpoint with retry logic
            max_attempts=20
            attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              echo "Health check attempt $attempt/$max_attempts"
              
              if curl -f --connect-timeout 5 --max-time 10 -s http://localhost:$TEST_PORT/health; then
                echo ""
                echo "✅ Health check passed on attempt $attempt"
                break
              else
                echo "Health check failed (attempt $attempt/$max_attempts)"
                
                if [ $attempt -eq $max_attempts ]; then
                  echo "ERROR: Health check failed after $max_attempts attempts"
                  echo ""
                  echo "=== Container Status ==="
                  docker ps -a --filter name=sqlite-otel-test
                  echo ""
                  echo "=== Container Logs ==="
                  docker logs sqlite-otel-test
                  echo ""
                  echo "=== Container Processes ==="
                  docker exec sqlite-otel-test ps aux 2>/dev/null || echo "Could not access container processes"
                  echo ""
                  echo "=== Network Check ==="
                  netstat -tuln | grep $TEST_PORT || echo "Port $TEST_PORT not listening"
                  echo ""
                  echo "=== Container Environment ==="
                  docker exec sqlite-otel-test env 2>/dev/null || echo "Could not access container environment"
                  exit 1
                fi
                
                sleep 3
                attempt=$((attempt + 1))
              fi
            done
      - run:
          name: Test Docker container functionality
          command: |
            set -e
            echo "Testing Docker container OTLP endpoint..."
            
            # Source the test port
            source $BASH_ENV
            echo "Testing OTLP endpoint on port $TEST_PORT"
            
            # Test OTLP endpoint with a simple trace
            echo "Sending test trace data..."
            if curl -X POST http://localhost:$TEST_PORT/v1/traces \
              --connect-timeout 5 \
              --max-time 15 \
              -H "Content-Type: application/json" \
              -w "HTTP Status: %{http_code}\n" \
              -d '{
                "resourceSpans": [
                  {
                    "resource": {
                      "attributes": [
                        {"key": "service.name", "value": {"stringValue": "ci-test-service"}}
                      ]
                    },
                    "scopeSpans": [
                      {
                        "spans": [
                          {
                            "traceId": "12345678901234567890123456789012",
                            "spanId": "1234567890123456",
                            "name": "ci-test-span",
                            "startTimeUnixNano": "1609459200000000000",
                            "endTimeUnixNano": "1609459201000000000"
                          }
                        ]
                      }
                    ]
                  }
                ]
              }'; then
              echo "✅ OTLP trace endpoint test passed"
            else
              echo "⚠ OTLP endpoint test had issues (this may be expected for some responses)"
            fi
            
            echo "✅ Container functionality test completed"
      - run:
          name: Test Docker container resource usage
          command: |
            set -e
            echo "Checking Docker container resource usage..."
            
            # Get container stats with timeout
            timeout 10 docker stats sqlite-otel-test --no-stream || echo "Stats collection timed out"
            
            echo "Resource usage check completed"
      - run:
          name: Validate Docker image security
          command: |
            set -e
            echo "Validating Docker image security..."
            
            # Check that container runs as non-root user
            user_id=$(docker exec sqlite-otel-test id -u)
            if [ "$user_id" -eq 0 ]; then
              echo "ERROR: Container is running as root user (security risk)"
              exit 1
            fi
            echo "✓ Container runs as non-root user (UID: $user_id)"
            
            # Check for health check configuration
            health_check=$(docker inspect sqlite-otel-test --format '{{.Config.Healthcheck}}')
            if [ "$health_check" = "<nil>" ]; then
              echo "ERROR: No health check configured"
              exit 1
            fi
            echo "✓ Health check is configured"
            
            echo "Security validation passed"
      - run:
          name: Cleanup Docker test container
          command: |
            echo "Cleaning up test container..."
            docker stop sqlite-otel-test || true
            docker rm sqlite-otel-test || true
            echo "Cleanup completed"
      - run:
          name: Save Docker image
          command: |
            set -e
            echo "Saving Docker image..."
            mkdir -p docker-artifacts
            docker save sqlite-otel-collector:test | gzip > docker-artifacts/sqlite-otel-collector-test.tar.gz
            echo "Docker image saved to artifacts"
            ls -la docker-artifacts/
      - store_artifacts:
          path: docker-artifacts/
          destination: docker-image

  # Fourth: Create release (only for tags)
  release:
    executor: go-executor
    steps:
      - checkout
      - attach_workspace:
          at: .
      - run:
          name: Create release archives
          command: |
            echo "Creating release archives..."
            make release
            echo "Release archives created:"
            ls -la releases/
      - store_artifacts:
          path: releases/
          destination: releases

workflows:
  version: 2.1
  build-test-docker:
    jobs:
      # Step 1: Build first
      - build:
          filters:
            branches:
              only: /.*/
            tags:
              only: /.*/
      
      # Step 2: Test after successful build
      - test:
          requires:
            - build
          filters:
            branches:
              only: /.*/
            tags:
              only: /.*/
      
      # Step 3: Build and validate Docker container after successful tests
      - docker-build-and-test:
          requires:
            - test
          filters:
            branches:
              only: /.*/
            tags:
              only: /.*/
      
      # Step 4: Create release (only for version tags)
      - release:
          requires:
            - docker-build-and-test
          filters:
            branches:
              ignore: /.*/
            tags:
              only: /^v.*/